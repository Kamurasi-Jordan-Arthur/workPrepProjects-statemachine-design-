//$file${.::elevator.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: elevetor.qm
// File:  ${.::elevator.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::elevator.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "elevator.h"
#include "qpc.h"
#include "bsp.h"
#include "string.h"
#include "usbd_cdc_if.h"
#include "string.h"
#include <stdio.h>
Q_DEFINE_THIS_FILE

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Elevator} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Elevator} ...........................................................

//${AOs::Elevator::SM} .......................................................
QState Elevator_initial(Elevator * const me, void const * const par) {
    //${AOs::Elevator::SM::initial}
    (void) par;

     const char* msg =
         "\t\t\tThe Elevator Operation System.\n"
         "\tPress any of the digits (0-9) to send a request to the Operation System.\n"
         "\tPress \"I\" to interrupt at a closing operation.\n"
         "\tPress \"C\" to clear all requests.\n";

     while (CDC_Transmit_FS((uint8_t*)msg, strlen(msg)) != USBD_OK) {
         HAL_Delay(4);
     }
    //'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    strcpy(me->doorState, "Closed");
    strcpy(me->dir, "STATIC");

    //'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


    // state history attributes
    me->hist_motion = Q_STATE_CAST(&Elevator_upWards);
    return Q_TRAN(&Elevator_operational);
}

//${AOs::Elevator::SM::operational} ..........................................
QState Elevator_operational(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Elevator_Stationary);
            break;
        }
        //${AOs::Elevator::SM::operational::PRINT}
        case PRINT_SIG: {
                 const char* msg =
                     "\n\n\n\t\t\tThe Elevator Operation System.\n"
                     "\tPress any of the digits (0-9) to send an Enter or Exit request to the Operation System.\n"
                     "\tPress \"I\" to interrupt at a closing operation.\n"
                     "\tPress \"C\" to clear all requests.\n";

                 while (CDC_Transmit_FS((uint8_t*)msg, strlen(msg)) != USBD_OK) {
                     HAL_Delay(4);
                 }


                 char buffer[128];
                 snprintf(buffer, sizeof(buffer), "%-4s %-15s %-15s %-15s %-15s %-10s\n",
                          "ID", "Current-Level", "Next-Level", "Direction", "Door State", "REQUESTS");


                 while (CDC_Transmit_FS((uint8_t*)buffer, strlen(buffer)) != USBD_OK) {
                     HAL_Delay(4);
                 }

                 refreshFeed();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::Stationary} ..............................
QState Elevator_Stationary(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::Stationary}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->stationaryTEvt);
            orangeOn();

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Elevator_closed);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_operational);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::Stationary::Closing} .....................
QState Elevator_Closing(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::Stationary::Closing}
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->stationaryTEvt, CLOSING_TIME, 0U); /*<== one shot */

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::Closing::sTIMEOUT}
        case sTIMEOUT_SIG: {
            strcpy(me->doorState, "Closed");
            refreshFeed();
            //${AOs::Elevator::SM::operational::Stationary::Closing::sTIMEOUT::[registry_Empyt()]}
            if (registry_Empyt()) {
                status_ = Q_TRAN(&Elevator_closed);
            }
            //${AOs::Elevator::SM::operational::Stationary::Closing::sTIMEOUT::[else]}
            else {
                strcpy(me->doorState, "Closed");
                refreshFeed();
                status_ = Q_TRAN_HIST(me->hist_motion);
            }
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::Closing::CLOSE_INTERRUPT}
        case CLOSE_INTERRUPT_SIG: {
            QTimeEvt_disarm(&me->stationaryTEvt);
            register_request(me->current);
            strcpy(me->doorState, "Openning");
            refreshFeed();
            status_ = Q_TRAN(&Elevator_Openning);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_Stationary);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::Stationary::Openning} ....................
QState Elevator_Openning(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::Stationary::Openning}
        case Q_ENTRY_SIG: {
            orangeOff();
            QTimeEvt_armX(&me->stationaryTEvt, OPENNING_TIME, 0U); /*<== one shot */

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::Openning::sTIMEOUT}
        case sTIMEOUT_SIG: {
            strcpy(me->doorState, "Opened");
            refreshFeed();
            status_ = Q_TRAN(&Elevator_Opened);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_Stationary);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::Stationary::Opened} ......................
QState Elevator_Opened(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::Stationary::Opened}
        case Q_ENTRY_SIG: {
            redOn();

            QTimeEvt_armX(&me->stationaryTEvt, OPENED_WAIT_TIME, 0U); /*<== one shot */
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::Opened}
        case Q_EXIT_SIG: {
            redOff();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::Opened::sTIMEOUT}
        case sTIMEOUT_SIG: {
            unregister_request(me->current);
            strcpy(me->doorState, "Clossing");
            refreshFeed();
            status_ = Q_TRAN(&Elevator_Closing);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_Stationary);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::Stationary::closed} ......................
QState Elevator_closed(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::Stationary::closed}
        case Q_ENTRY_SIG: {
            orangeOn();

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::Stationary::closed::RESUME}
        case RESUME_SIG: {
            //${AOs::Elevator::SM::operational::Stationary::closed::RESUME::[me->current==getLowestRequest(m~}
            if (me->current == getLowestRequest(me->current)) {
                strcpy(me->doorState, "Openning");
                refreshFeed();
                status_ = Q_TRAN(&Elevator_Openning);
            }
            //${AOs::Elevator::SM::operational::Stationary::closed::RESUME::[else]}
            else {
                status_ = Q_TRAN_HIST(me->hist_motion);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_Stationary);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::motion} ..................................
QState Elevator_motion(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::motion}
        case Q_EXIT_SIG: {
            // save shallow history
            me->hist_motion =
                QHsm_childState(Q_HSM_UPCAST(me),
                                Q_STATE_CAST(&Elevator_motion));
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::motion::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Elevator_upWards);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_operational);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::motion::upWards} .........................
QState Elevator_upWards(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::motion::upWards}
        case Q_ENTRY_SIG: {
            greenOn();
            strcpy(me->dir, "upWards");


            me->next = getLowestRequest(me->current);
            //........................................................

            if(me->next < me->current ){
                static const QEvt sitchEvt = QEVT_INITIALIZER(SWITCH_SIG);
                QACTIVE_POST_LIFO(AOElevator, &sitchEvt);
            }else {
                QTimeEvt_armX(&me->motionTEvt, TRANSITION_INTERVAL, TRANSITION_INTERVAL);
                refreshFeed();
            }

            //........................................................

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::motion::upWards}
        case Q_EXIT_SIG: {
            greenOff();
            QTimeEvt_disarm(&me->motionTEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::motion::upWards::mTIMEOUT}
        case mTIMEOUT_SIG: {
            me->current++;
            //${AOs::Elevator::SM::operational::motion::upWards::mTIMEOUT::[me->current==me->next]}
            if (me->current == me->next) {
                strcpy(me->dir, "STATIC");
                refreshFeed();
                strcpy(me->doorState, "Openning");
                refreshFeed();

                status_ = Q_TRAN(&Elevator_Openning);
            }
            //${AOs::Elevator::SM::operational::motion::upWards::mTIMEOUT::[else]}
            else {
                refreshFeed();
                status_ = Q_HANDLED();
            }
            break;
        }
        //${AOs::Elevator::SM::operational::motion::upWards::REQUEST}
        case REQUEST_SIG: {
            //${AOs::Elevator::SM::operational::motion::upWards::REQUEST::[closerThanNext]}
            if (me->next > Q_EVT_CAST(requestEvt)->level && Q_EVT_CAST(requestEvt)->level > me->current
)
            {
                uint8_t assetion = already_requested( Q_EVT_CAST(requestEvt)->level);
                Q_ASSERT(assetion);
                me->next = Q_EVT_CAST(requestEvt)->level;
                refreshFeed();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        //${AOs::Elevator::SM::operational::motion::upWards::SWITCH}
        case SWITCH_SIG: {
            status_ = Q_TRAN(&Elevator_downWards);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_motion);
            break;
        }
    }
    return status_;
}

//${AOs::Elevator::SM::operational::motion::downWards} .......................
QState Elevator_downWards(Elevator * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Elevator::SM::operational::motion::downWards}
        case Q_ENTRY_SIG: {
            blueOn();
            strcpy(me->dir, "downWards");

            me->next = getHighestRequest(me->current);
            //........................................................

            if(me->next > me->current ){
                static const QEvt sitchEvt = QEVT_INITIALIZER(SWITCH_SIG);
                QACTIVE_POST_LIFO(AOElevator, &sitchEvt);
            }else {
                QTimeEvt_armX(&me->motionTEvt, TRANSITION_INTERVAL, TRANSITION_INTERVAL);
                refreshFeed();
            }
            //........................................................


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::motion::downWards}
        case Q_EXIT_SIG: {
            blueOff();
            QTimeEvt_disarm(&me->motionTEvt);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Elevator::SM::operational::motion::downWards::REQUEST}
        case REQUEST_SIG: {
            //${AOs::Elevator::SM::operational::motion::downWards::REQUEST::[closerThanNext]}
            if (me->next < Q_EVT_CAST(requestEvt)->level && Q_EVT_CAST(requestEvt)->level < me->current) {
                Q_ASSERT(already_requested( Q_EVT_CAST(requestEvt)->level));
                me->next = Q_EVT_CAST(requestEvt)->level;
                refreshFeed();
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        //${AOs::Elevator::SM::operational::motion::downWards::mTIMEOUT}
        case mTIMEOUT_SIG: {
            me->current--;
            //${AOs::Elevator::SM::operational::motion::downWards::mTIMEOUT::[me->current==me->next]}
            if (me->current == me->next) {
                strcpy(me->dir, "STATIC");
                refreshFeed();
                strcpy(me->doorState, "Openning");
                refreshFeed();

                status_ = Q_TRAN(&Elevator_Openning);
            }
            //${AOs::Elevator::SM::operational::motion::downWards::mTIMEOUT::[else]}
            else {
                refreshFeed();
                status_ = Q_HANDLED();
            }
            break;
        }
        //${AOs::Elevator::SM::operational::motion::downWards::SWITCH}
        case SWITCH_SIG: {
            status_ = Q_TRAN(&Elevator_upWards);
            break;
        }
        default: {
            status_ = Q_SUPER(&Elevator_motion);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::Elevator} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AOs::Elevator_inst} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Elevator_inst} ......................................................
static Elevator Elevator_inst;
//$enddef${AOs::Elevator_inst} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AOs::Elevator_Ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Elevator_Ctor} ......................................................
void Elevator_Ctor(void) {
    Elevator * me = &Elevator_inst;
    QActive_ctor(&me->super, Q_STATE_CAST(&Elevator_initial));
    QTimeEvt_ctorX(&me->motionTEvt, &me->super, mTIMEOUT_SIG, 0U);
    QTimeEvt_ctorX(&me->stationaryTEvt, &me->super, sTIMEOUT_SIG, 0U);
    me->current = 0U;
}
//$enddef${AOs::Elevator_Ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AOs::AOElevator} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::AOElevator} .........................................................
QActive * AOElevator = &Elevator_inst.super;
//$enddef${AOs::AOElevator} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AOs::Requestor}

//$define${AOs::Requestor_inst}

//$define${AOs::Requestor_Ctor}

//$define${AOs::AORequestor}

void refreshFeed(void){

    char buffer[128];
    snprintf(buffer, sizeof(buffer),
             "%-4d %-15d %-15d %-15s %-15s 0x%08X\n",
             Elevator_inst.iD++,
             Elevator_inst.current,
             Elevator_inst.next,
             Elevator_inst.dir,
             Elevator_inst.doorState,
             requests);

    while (CDC_Transmit_FS((uint8_t*)buffer, strlen(buffer)) != USBD_OK) {
        HAL_Delay(4); // or use busy wait
    }
}



//$define${shared::requests} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${shared::requests} ........................................................
volatile uint16_t requests =0U;
//$enddef${shared::requests} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

