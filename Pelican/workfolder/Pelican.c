//$file${Components::.::Pelican.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: Pelican.qm
// File:  ${Components::.::Pelican.c}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${Components::.::Pelican.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "pelican.h"
#include "bsp.h"
#include "qpc.h"
#include "safe_std.h" // portable "safe" <stdio.h>/<string.h> facilities

Q_DEFINE_THIS_FILE


//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${Components::Pelican} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${Components::Pelican} .....................................................
Pelican Pelican_inst;

//${Components::Pelican::const} ..............................................
void Pelican_const(Pelican * const me) {
    (void) me;
    QActive_ctor(&Pelican_inst.super, Q_STATE_CAST(&Pelican_initial));
    QTimeEvt_ctorX(&Pelican_inst.car_timer,   &Pelican_inst.super, CAR_TIME_SIG,   0U);
    QTimeEvt_ctorX(&Pelican_inst.ped_timer, &Pelican_inst.super, PEDS_TIME_SIG, 0U);

    //me->Pelican_started =0U;

}

//${Components::Pelican::SM} .................................................
QState Pelican_initial(Pelican * const me, void const * const par) {
    //${Components::Pelican::SM::initial}
    //The application initial transition
    (void)par; // unused parameter

    PRINTF_S("\n%s\t\t\t%s\n", "car_SMS", "peds_SMS");
    BSP_UP_DATE();


    QS_FUN_DICTIONARY(&Pelican_operational);
    QS_FUN_DICTIONARY(&Pelican_no_peds);
    QS_FUN_DICTIONARY(&Pelican_peds_waiting);
    QS_FUN_DICTIONARY(&Pelican_onCarGracePeriod);
    QS_FUN_DICTIONARY(&Pelican_readyingToWalk);
    QS_FUN_DICTIONARY(&Pelican_walking);
    QS_FUN_DICTIONARY(&Pelican_walkLight);
    QS_FUN_DICTIONARY(&Pelican_dontWalkFlash);
    QS_FUN_DICTIONARY(&Pelican_Offline);

    return Q_TRAN(&Pelican_Offline);
}

//${Components::Pelican::SM::operational} ....................................
QState Pelican_operational(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "OPERATIONAL-ENTRY;");

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "OPERATIONAL-EXIT;");
            QTimeEvt_disarm(&me->car_timer);
            QTimeEvt_disarm(&me->ped_timer);
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::initial}
        case Q_INIT_SIG: {
            //#begins with cars moving an assumes no peds

            status_ = Q_TRAN(&Pelican_no_peds);
            break;
        }
        //${Components::Pelican::SM::operational::OFF}
        case OFF_SIG: {
            //key borad press of "esc"
            status_ = Q_TRAN(&Pelican_Offline);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::no_peds} ...........................
QState Pelican_no_peds(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::no_peds}
        case Q_ENTRY_SIG: {
            //Arm the car timer
            me->timer_status = WAITING_4_NONE;
            bspCarsGreen();
            QTimeEvt_armX(&me->car_timer, 5U*BSP_TICKS_PER_SEC, 0U);
            //PRINTF_S("%s\n", "no_peds-ENTRY;");

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::no_peds}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s\n", "no-peds-Exit;");
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::no_peds::CAR_TIME}
        case CAR_TIME_SIG: {
            me->timer_status = WAITING_CAR_GRACE;
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::no_peds::PEDS}
        case PEDS_SIG: {
            //${Components::Pelican::SM::operational::no_peds::PEDS::[stillCarGrace]}
            if (me->timer_status == WAITING_4_NONE) {
                status_ = Q_TRAN(&Pelican_onCarGracePeriod);
            }
            //${Components::Pelican::SM::operational::no_peds::PEDS::[else]}
            else {
                status_ = Q_TRAN(&Pelican_readyingToWalk);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_operational);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::peds_waiting} ......................
QState Pelican_peds_waiting(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::peds_waiting}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "peds_waiting-ENTRY;");

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::peds_waiting}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "peds_waiting-EXIT;");
            bspCarsRed();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_operational);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::peds_waiting::onCarGracePeriod} ....
QState Pelican_onCarGracePeriod(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::peds_waiting::onCarGracePeriod}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "onCarGracePeriod-ENTRY;");

            me->timer_status = WAITING_CAR_GRACE;
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::peds_waiting::onCarGracePeriod}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "onCarGracePeriod-EXIT;");

            me->timer_status = WAITING_4_NONE;
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::peds_waiting::onCarGracePeriod::CAR_TIME}
        case CAR_TIME_SIG: {
            status_ = Q_TRAN(&Pelican_readyingToWalk);
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_peds_waiting);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::peds_waiting::readyingToWalk} ......
QState Pelican_readyingToWalk(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::peds_waiting::readyingToWalk}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "readyingToWalk-ENTRY;");
            bspCarsYellow();
            QTimeEvt_armX(&me->ped_timer, 2U*BSP_TICKS_PER_SEC, 0U);
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::peds_waiting::readyingToWalk}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "readyingToWalk-EXIT;");

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::peds_waiting::readyingToWalk::PEDS_TIME}
        case PEDS_TIME_SIG: {
            status_ = Q_TRAN(&Pelican_walkLight);
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_peds_waiting);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::walking} ...........................
QState Pelican_walking(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::walking}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "walking-ENTRY;");
            bspWalk();

            QTimeEvt_armX(&me->ped_timer, 3U * BSP_TICKS_PER_SEC, 0U);

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::walking}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "walking-EXIT;");

            //bspDontWalk();

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_operational);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::walking::walkLight} ................
QState Pelican_walkLight(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::walking::walkLight}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "walkLight-ENTRY;");


            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::walking::walkLight}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "walkLight-EXIT;");

            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::walking::walkLight::PEDS_TIME}
        case PEDS_TIME_SIG: {
            status_ = Q_TRAN(&Pelican_dontWalkFlash);
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_walking);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::operational::walking::dontWalkFlash} ............
QState Pelican_dontWalkFlash(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::operational::walking::dontWalkFlash}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s", "dontWalkFlash-ENTRY;");

            me->count =0U;
            QTimeEvt_armX(&me->ped_timer, BSP_TICKS_PER_SEC / 2U , BSP_TICKS_PER_SEC / 2U);
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::walking::dontWalkFlash}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s", "dontWalkFlash-EXIT;");
            QTimeEvt_disarm(&me->ped_timer);
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::operational::walking::dontWalkFlash::PEDS_TIME}
        case PEDS_TIME_SIG: {
            //${Components::Pelican::SM::operational::walking::dontWalkFlash::PEDS_TIME::[Flashthreetimes]}
            if (me->count > 3U) {
                status_ = Q_TRAN(&Pelican_no_peds);
            }
            //${Components::Pelican::SM::operational::walking::dontWalkFlash::PEDS_TIME::[elseIncrementCounter]}
            else {
                bspDontWalkFlash((me->count << 7U) ^ 0U);
                me->count ++;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Pelican_walking);
            break;
        }
    }
    return status_;
}

//${Components::Pelican::SM::Offline} ........................................
QState Pelican_Offline(Pelican * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${Components::Pelican::SM::Offline}
        case Q_ENTRY_SIG: {
            //PRINTF_S("%s\n", "Offline-ENTRY;");
            //QASSERT(TIMER_DISARM(&me->car_timer) && TIMER_DISARM(&me->ped_timer));



            // may need to trace the return values of the disarm here
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::Offline}
        case Q_EXIT_SIG: {
            //PRINTF_S("%s\n", "offline-EXIT;");
            status_ = Q_HANDLED();
            break;
        }
        //${Components::Pelican::SM::Offline::ON}
        case ON_SIG: {
            status_ = Q_TRAN(&Pelican_operational);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${Components::Pelican} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

QActive * Pelican_AO = &Pelican_inst.super;

